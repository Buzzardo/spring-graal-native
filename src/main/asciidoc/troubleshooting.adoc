[[troubleshooting]]
== Troubleshooting

Whilst trying to build native images various things can go wrong, either at image build time or at runtime when attempting to launch the built image.
Usually the problem is a lack of configuration - GraalVM native-image wasn't told about the application intending to reflectively call something or load a resource.
But there can also be more serious problems, native-image crashing or the application using a third party library that includes code not compatible with native-image.

This page will explore some of the errors that can encountered and any fixes or workarounds possible.
The two main sections of this page are problems at image build time and problems at image runtime.

The Spring team is actively working with the Graal team on issues, those currently open can be seen https://github.com/oracle/graal/projects/2?card_filter_query=label%3Aspring[here].
This page tracks spring labelled issues on the Graal issue tracker.

=== `native-image` is failing

==== out of memory when building the native image

`native-image` consumes a lot of RAM.
We have most success on 32G RAM desktop machines.
16G is possible for smaller samples but 8G machines are likely to hit problems more often.

==== Weird crash

====
[source,bash]
----
Exception during JVMCI compiler initialization:
Exception in thread "main": java.lang.ExceptionInInitializerError
java.lang.ExceptionInInitializerError
	at com.oracle.svm.core.hub.ClassInitializationInfo.initialize(ClassInitializationInfo.java:290)
	at java.lang.Class.ensureInitialized(DynamicHub.java:496)
	at java.lang.System.getenv(System.java:897)
	at org.graalvm.libgraal.jni.JNIUtil.traceLevel(JNIUtil.java:268)
	at org.graalvm.libgraal.jni.JNIUtil.trace(JNIUtil.java:292)
	at org.graalvm.libgraal.jni.HotSpotToSVMScope.<init>(HotSpotToSVMScope.java:114)
	at org.graalvm.compiler.hotspot.management.libgraal.HotSpotGraalManagement.defineClassesInHotSpot(HotSpotGraalManagement.java:170)
	at org.graalvm.compiler.hotspot.management.libgraal.HotSpotGraalManagement.initialize(HotSpotGraalManagement.java:115)
	at org.graalvm.compiler.hotspot.HotSpotGraalRuntime.<init>(HotSpotGraalRuntime.java:178)
	at org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory.createCompiler(HotSpotGraalCompilerFactory.java:156)
	at org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory.createCompiler(HotSpotGraalCompilerFactory.java:134)
	at org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory.createCompiler(HotSpotGraalCompilerFactory.java:52)
	at jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.getCompiler(HotSpotJVMCIRuntime.java:599)
	at jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.compileMethod(HotSpotJVMCIRuntime.java:667)
	at com.oracle.svm.jni.JNIJavaCallWrappers.jniInvoke_VA_LIST_Nonvirtual:Ljdk_vm_ci_hotspot_HotSpotJVMCIRuntime_2_0002ecompileMethod_00028Ljdk_vm_ci_hotspot_HotSpotResolvedJavaMethod_2IJI_00029Ljdk_vm_ci_hotspot_HotSpotCompilationRequestResult_2(JNIJavaCallWrappers.java:0)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 83 out of bounds for length 82
	at com.oracle.svm.jni.functions.JNIFunctions.SetObjectArrayElement(JNIFunctions.java:683)
	at java.lang.ProcessEnvironment.environ(ProcessEnvironment.java)
	at java.lang.ProcessEnvironment.<clinit>(ProcessEnvironment.java:70)
	at com.oracle.svm.core.hub.ClassInitializationInfo.invokeClassInitializer(ClassInitializationInfo.java:350)
	at com.oracle.svm.core.hub.ClassInitializationInfo.initialize(ClassInitializationInfo.java:270)
	... 14 more
Error: Image build request failed with exit status 255
----
====

This has been seen with Graal 20.0 - current workaround is just to re-run, it is intermittent.

=== the built image will not run

==== missing resource bundles

In some cases when there is a problem the error message will try to tell you exactly what to do:

====
[source,bash]
----
Caused by: java.util.MissingResourceException:
  Resource bundle not found javax.servlet.http.LocalStrings.
  Register the resource bundle using the option
    -H:IncludeResourceBundles=javax.servlet.http.LocalStrings.
----
====

Here it is clear we should add `-H:IncludeResourceBundles=javax.servlet.http.LocalStrings` to the `<buildArgs>` section in the `pom.xml`.

==== ClassNotFoundException

====
[source,bash]
----
Caused by: java.lang.ClassNotFoundException:
  org.apache.catalina.authenticator.jaspic.AuthConfigFactoryImpl
	at com.oracle.svm.core.hub.ClassForNameSupport.forName(ClassForNameSupport.java:60) ~[na:na]
----
====

This indicates the native-image build wasn't told about the reflective need for a type and so did not include the data to satisfy a request to access it at runtime.

If using the agent, it can be a sign the agent is missing something (this particular message here was collected whilst debugging https://github.com/oracle/graal/issues/2198[issue 2198]).

Options to address it:

* download a new version of GraalVM that includes a fixed agent.

* raise a bug against the `spring-graal-native` project as a key aim of the feature is to make sure these things get registered.
If not 'obvious' that it should be registered then it may be necessary for a new or expanded hint to the added to the `spring-graal-native-configuration` project (see the extension guide for more into if you want to explore that)

* manually add it.
The native-image run will pick up any configuration it finds.
In this case just create a `reflect-config.json` under a `META-INF/native-image` folder structure and ensure that is on the classpath.
This is sometimes easiest just by creating it in your project `src/main/resources` folder (so `src/main/resources/META-INF/native-image/reflect-config.json`).
An entry to satisfy the above error would look like this.
Note there are various access options to specify.
Here we are setting `allDeclaredConstructors` and `allDeclaredMethods`.
We might need `allDeclaredFields` if the code is intending to reflect on those too.

====
[source,bash]
----
[
{
 "name":"org.apache.catalina.authenticator.jaspic.AuthConfigFactoryImpl",
 "allDeclaredConstructors":true,
 "allDeclaredMethods":true
}
]
----
====

Recompiling should pick up this extra config and the resultant image will include metadata to satisfy reflection of `AuthConfigFactoryImpl`

=== Where has my logging gone?

In standard operation `native-image` uses a server to optimize compilation speeds. Using the server has been known to produce native images that are missing logging. In this case add `--no-server` to the arguments being passed to `native-image`.

==== No access hint found for import selector: XXX

The feature chases down configuration references to other configurations (`@Import` usages).
However if using an import selector, that means code is deciding what the next imported configuration should be, which is harder to follow.
The feature doesn't do that level of analysis (it could get very complicated).
This means although the feature can tell it has encountered a selector, it doesn't know what types that selector needs reflective access to or what further configurations it is referencing.
Now, the feature could just continue - maybe it would work, maybe it would crash at runtime.
Typically the error you get can when there is a missing hint can be very cryptic. If the selector is doing a "if this type is around return this configuration to include" then it may simply be not finding some type (when it is really there, just not exposed in the image) and not including some critical configuration.
For this reason the feature fails early and fast indicating it doesn't know what a particular selector is doing.
To fix it, take a look in the selector in question and craft a quick hint for it.
See {project-home}/commit/1251a274f81a3087b456d2178d2ae6405676d23b[this commit] that was fixing this kind of problem for spring security ({project-home}/issues/60[issue]).

_IF_ you are feeling brave, you can temporarily turn this hard error into a warning.
It is possible that in your case you don't need what the selector is doing.
Specify the option `-Dspring.graal.missing-selector-hints=warning` - this will cause log messages about the problem but not a hard fail.
Beware :)

=== Diagnosing issues with the feature

Sometimes you want to use the feature but can't - maybe you like that the feature does offer that more optimal mode of discarding unecessary configuration at image build time which the agent mode doesn't.
When using the feature you either get an error about some missing piece of configuration, or worse you get no error and it doesn't work (implying there is probably missing configuration but it isn't critical for the app to start, it is just critical for it to actually work!).
If the error is clear then you can follow the guidlines in the <<extension_guide,extension guide>> and perhaps contribute it back.
But in the case where you have no idea, what do you do?

The first step to take here is try and run it with the agent.

====
[source,bash]
----
mkdir -p native-image-config
mvn clean package
java -agentlib:native-image-agent=config-output-dir=native-image-config \
  -jar target/myapp-0.0.1-SNAPSHOT.jar
----
====
After hitting the app via whatever endpoints you want to be exercised and shutting it down, there will be config files in the output folder:

====
[source,bash]
----
ls -l native-image-config
-rw-r--r--  1 foo bar    135 26 Mar 11:25 jni-config.json
-rw-r--r--  1 foo bar    277 26 Mar 11:25 proxy-config.json
-rw-r--r--  1 foo bar  32132 26 Mar 11:25 reflect-config.json
-rw-r--r--  1 foo bar    461 26 Mar 11:25 resource-config.json
----
====

Now, we want to compare that native-image-config/reflect-config.json with the configuration being produced by the feature.
Luckily the feature supports a dump mode where it will put it out on disk for us to see.
Add this to the maven <buildArgs>...</buildArgs> section or as a parameter in the direct call to native-image.

====
[source,bash]
----
-DdumpConfig=/a/b/c/feature-reflect-config.json
----
====

Then after running the native image build again that file will exist.
It is now possible to diff the computed one with the agent one. The scripts folder in spring-graal-native contains a compare script:

====
[source,bash]
----
~/spring-graal-native/scripts/reflectCompare.sh feature-reflect-config.json native-image-config/reflect-config.json > diff.txt
----
====

This will produce a summary of the differences.
It understands the format a little better than just doing a 'diff':

====
[source,bash]
----
$ tail diff.txt
...

Summary:
In first but not second: 395
In second but not first: 69
In both files but configured differently: 51
In both files and configured the same: 67

----
====

We might search that for what entries are in the agent file that aren't in the computed file for Spring:

====
[source,bash]
----
grep "^> org.spring" diff.txt
----
====

This will show data like this:

====
[source,bash]
----
> org.springframework.context.ApplicationEventPublisherAware setFlags:[allPublicMethods]
> org.springframework.context.ApplicationListener setFlags:[allPublicMethods]
> org.springframework.context.EnvironmentAware setFlags:[allPublicMethods]
> org.springframework.context.SmartLifecycle setFlags:[allPublicMethods]
> org.springframework.core.annotation.AliasFor setFlags:[allDeclaredMethods]
> org.springframework.core.annotation.SynthesizedAnnotation
----
====

These can be crafted into a config file for the project:

====
[source,bash]
----
mkdir -p src/main/resources/META-INF/native-image
----
====

Now create src/main/resources/META-INF/native-image/reflect-config.json with content like this (just including the first one from the diff in this example):

====
[source,bash]
----
[
{"name":"org.springframework.context.ApplicationEventPublisherAware","allPublicMethods":true}
]
----
====

As we add the ones found in the diff we can rebuild the native-image each time and see which help.
Once computed, we can create a hint in the feature configuration project that captures this knowledge (see the <<extension_guide,extension guide>> for more info on that) or, if it is more related to this specific application than the infrastructure, we might leave that reflect-config.json in the project and commit it to our repository alongside the source for future use.
